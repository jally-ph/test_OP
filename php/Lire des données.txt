08/02/2019

		LISEZ DES DONNEES



**Se connecter à la base de données en PHP**

extension mysql_ => vieilles fonctions qu'il ne faut plus utiliser

extension mysqli_ => fct° améliorées, à utiliser

entension PDO => outil qui connecte à n'importe quelle bdd, à utiliser

Php a bcoup d'extensions

*Activer PDO*

dans WAMP + clique gauche + dans le menu : 
PHP / Extensions PHP + php_pdo_mysql doit être coché

*Se connecter à Mysql avec PDO*

4 renseignements à avoir: 

- le nom de l'hôte =>adresse de l'ordi où est mysql (ex: localhost / sql.hebergeur.com) 
On aura alors cela à modifier qd on enverra le site sur le net

- la base => nom de la bdd à laquelle on doit se connecter

- le login => permet l'authentification (voir serveur/hébergeur)

- le mot de passe => voir serveur/hébergeur


!! par défaut le login est "root" et ya pas de password !!

!! à mettre dans le fichier php :
<?php
// Sous WAMP (Windows)
$bdd = new PDO('mysql:host=localhost;dbname=test;charset=utf8', 'root', '');
?>

PDO = extension orientée objet

la ligne de code dessus crée un OBJET 
$bdd => n'est pas une variable, c'est un objet (symbolise la connection à la bdd)

ordre des paramètres :

- le nom d'hote (localhost)
- la bdd (test ici)
- le login (root)
- le password (' ')

DSN = Data Source Name


**Tester la présence d'erreurs**

en cas d'erreur : PDO renvoie une EXCEPTION, qui capture l'erreur

!! pr ce faire, écrire :

<?php
try
{
	$bdd = new PDO('mysql:host=localhost;dbname=test;charset=utf8', 'root', '');
}
catch (Exception $e)
{
        die('Erreur : ' . $e->getMessage());
}
?>


**Récupérer des données**

*Faire une requête*

langage SQL

!! on écrit :
$reponse = $bdd->query('Tapez votre requête SQL ici');


query = requête en eng

!! la requête sera :
SELECT * FROM jeux_video


SELECT => type de l'opération à effectuer (afficher le contenu d'une table)

* => Tous les champs st sélectionnés

FROM => où ça. depuis où.

jeux_vidéo => nom de la table, où aller prendre les infos


*Afficher le résultat d'une requête*

$reponse => nous donne des infos pas exploitables, trop d'infos
vaut mieux éxécuter "  fetch()  ", qui renvoie la 1ere ligne:

<?php
$donnees = $reponse->fetch();
?>

fetch => signifie "va chercher" en eng

$donnees => un array; faut une boucle pr avoir les entrées une à une de la table
while ($donnees = $reponse->fetch())


!! au final ça donne ça :

<?php
try
{
	// On se connecte à MySQL
	$bdd = new PDO('mysql:host=localhost;dbname=test;charset=utf8', 'root', '');
}
catch(Exception $e)
{
	// En cas d'erreur, on affiche un message et on arrête tout
        die('Erreur : '.$e->getMessage());
}

// Si tout va bien, on peut continuer

// On récupère tout le contenu de la table jeux_video
$reponse = $bdd->query('SELECT * FROM jeux_video');

// On affiche chaque entrée une à une
while ($donnees = $reponse->fetch())
{
?>
    <p>
    <strong>Jeu</strong> : <?php echo $donnees['nom']; ?><br />
    Le possesseur de ce jeu est : <?php echo $donnees['possesseur']; ?>, et il le vend à <?php echo $donnees['prix']; ?> euros !<br />
    Ce jeu fonctionne sur <?php echo $donnees['console']; ?> et on peut y jouer à <?php echo $donnees['nbre_joueurs_max']; ?> au maximum<br />
    <?php echo $donnees['possesseur']; ?> a laissé ces commentaires sur <?php echo $donnees['nom']; ?> : <em><?php echo $donnees['commentaires']; ?></em>
   </p>
<?php
}

$reponse->closeCursor(); // Termine le traitement de la requête

?>


la différence entre $reponse et $donnees :
$reponse avec ttes les infos mysql en vrac, sous forme d'objet
$donnees est un array que renvoie fetch()
while s'arrête dès que le fetch() renvoie FALSE, à la fin.

!! sert à fermerla requête-ci pr ne pas avoir de prob avec la suivante :
<?php $reponse->closeCursor(); ?>


*Afficher le contenu de seulement quelques champs*

Afficher que le nom des jeux vidéo :
SELECT nom FROM jeux_video


!! LA CONNEXION A LA BASE DE DONNEES NE SE FAIT QUUNE SEULE FOIS EN DEBUT 
DE PAGE 

FAUT FERMER LES RESULTATS DE REQUETES AVEC closeCursor() !!


**Les critères de sélection**

Filtrer et trier facilement les données

mots-clés du langage SQL :

- WHERE

Si je ne veux que les jeux de Patrick :
SELECT * FROM jeux_video WHERE possesseur='Patrick'

- AND

Pr combiner les mots-clés + les jeux de Patrick en dessous de 20€ :
SELECT * FROM jeux_video WHERE possesseur='Patrick' AND prix < 20

- OU

x

- ORDER BY

Permet d'ordonner les données, les classer; ex: les classer par prix croissants:
SELECT * FROM jeux_video ORDER BY prix

Par ordre décroissant :
SELECT * FROM jeux_video ORDER BY prix DESC

!! Order by sur du texte => classe par ordre alphabétique

- LIMIT

Permet de limiter le nbre de données affichées (utile pr paginer)
LIMIT + 2 nbre séparées par une virgule :

SELECT * FROM jeux_video LIMIT 0, 20

1er nbre => à partir de quelle entrée on commence à lire la table (0 pr la première entrée)
	20 pour la 21 entrées; décalage !

2è nbre => combien d'entrées à afficher

ex:
	LIMIT 5, 10 : affiche de la sixième à la quinzième entrée ;

	LIMIT 10, 2 : affiche la onzième et la douzième entrée.

ex requête :
SELECT nom, possesseur, console, prix FROM jeux_video WHERE console='Xbox' OR console='PS2' ORDER BY prix DESC LIMIT 0,10

!! TJOURS UTILISER LES MOTS CLES DANS L'ORDRE DONNE 
WHERE => ORDER BY => LIMIT  !!


**Construire des requêtes en fonction des variables**

*La mauvaise idée : concaténer une variable dans une requête*

ex - pour adapter la requête au nom de la personne, s'adapter à la demande de l'utilisateur 
avec $_GET['possesseur'] :
<?php
$reponse = $bdd->query('SELECT nom FROM jeux_video WHERE possesseur=\'' . $_GET['possesseur'] . '\'');
?>

!! Ce code fonctionne mais NE PAS L'UTILISER !! => risque de faille: "injection SQL"


*La solution : les requêtes préparées*

moyen plus sûr et rapide pour la bdd
requête préparée => vaut mieux l'uitliser pr adapter une requête en fonction d'une ou pls $

AVEC DES MARQUEURS "?"

on prépare d'abord la requête (sans la variable$)
pr ce faire, mettre un "?" :

<?php
$req = $bdd->prepare('SELECT nom FROM jeux_video WHERE possesseur = ?');
?>

au lieu de mettre QUERY, on met PREPARE() !! La quête est prête. 

on éxécute la requête et on appelle la liste des paramètres :

<?php
$req = $bdd->prepare('SELECT nom FROM jeux_video WHERE possesseur = ?');
$req->execute(array($_GET['possesseur']));
?>

si pls paramètres, attention à mettre dans le bon ordre :

<?php
$req = $bdd->prepare('SELECT nom FROM jeux_video WHERE possesseur = ? AND prix <= ?');
$req->execute(array($_GET['possesseur'], $_GET['prix_max']));
?>

=> les pts d'interrogations seront automatiquement remplacé respectivement par le contenu
des variables: $_GET['possesseur'] et $_GET['prix_max']. Le contenu des $ est automatiquemt
sécurisé; aucun risque d'injection SQL.

****ne pas oublier que les $ get doivent être définis en qq part.


AVEC DES MARQUEURS NOMINATIFS

si requête avec bcoup de $, plus pratique de nommer directement les $, au lieu du "?" :

<?php
$req = $bdd->prepare('SELECT nom, prix FROM jeux_video WHERE possesseur = :possesseur AND prix <= :prixmax');
$req->execute(array('possesseur' => $_GET['possesseur'], 'prixmax' => $_GET['prix_max']));
?>

au lieu des "?" : il y a des Marqueurs Nominatifs ( :possesseur ) symbole 2 pts.
+ array associatif
=> dans ce cas : l'ordre ne compte pas


**Traquer les erreurs**

Qd requête SQL plante => PHP dira erreur à fetch()  :
Fatal error: Call to a member function fetch() on a non-object in C:\wamp\www\tests\index.php on line 13

ce n'est pas fetch() qui cloche, erreur dans requête SQL plus haut

pr avoir des détails sur l'erreur => activer erreurs lors de la connexion à la bdd via PDO :

<?php
$bdd = new PDO('mysql:host=localhost;dbname=test;charset=utf8', 'root', '', 
array(PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION));
?>





::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::












